# :recycle: Software Life Cycle
Il modello di processo di riferimento, come già accenato nel <code>[Project Plan](ProjectPlan.pdf)</code>, sarà di tipo AGILE:
  * Si punterà, alla fine di ogni giornata lavorativa, a fornire un prototipo di stazione funzionante, consegnabile al cliente con in aggiunta, se possibile, nuove funzionalità.
  * Il coinvolgimento del committente sarà totale; il dispositivo, infatti, gli verrà mostrato periodicamente con la possibilità di testarlo e verificare se, effettivamente, soddifa i propri requisiti. Per questo motivo sarà, dunque, anche sollecitato nell'esprimere giudizi sinceri riguardo la versione consegnatagli.
  * Si dovrà, perciò, essere propensi al cambiamento, in modo tale da poter soddisfare la maggior parte delle eventuali rischieste che il cliente avanzerà come conseguenza dei propri test. L'obbiettivo sarà quello di implemetare tutte le nuove funzionalità che richiederà, cercando comunque di realizzare il tutto in continuità con quanto fatto fino a quel momento.
  * Per quanto riguarda la documentazione, ovviamente questà dovrà essere opportunamente aggiornata, ma, il punto centrale, rimarrà sempre il codice che avrà la priorità nel caso di eventuali aggiornamenti.
  * Per quanto concerne, invece, l'effettivo progredire dei lavori (sviluppo software) tutte le attività da svolgere verrano inserite in un backlog dal quale se ne estrarranno un numero definito da svolgere durante un intervallo di tempo di durata prestabilita. Al termine di questo lasso di tempo, eventuali funzionalità aggiuntive, aggiornamenti... dovranno essere completate. La conclusione di un intervallo di tempo coinciderà con l'inizio di uno nuovo, fino al termine delle attvità da sviluppare.

Infine, per quanto riguarda il paradigma di sviluppo software ci si atterrà alla tipologia MDA (Model-driven Architecture). In questo modo, anche la documentazione (nella maggior parte dei casi) potrà essere contestualmente aggiornata, dato che il modello ultimo (codice) non verrà quasi mai toccato, andando infatti a modificare solamente il modello indipendente dalla piattaforma (PIM), che, tramite raffinamento, "passerà" le modifiche direttamente al modello specifico (PSM).
